# 1. Тестирование ПО: основы

Тестирование --- это один из способов обеспечения качества ПО, в котором
пытаются обеспечить [функциональные](https://github.com/maratdin7/BoSE-answers#функциональные-требования) и [нефункциональные](https://github.com/maratdin7/BoSE-answers#нефункциональные-требования) требования.

* Функциональные требования --- делает ли ПО, что от него хотят
* Нефункциональные требования --- работает ли ПО, как должно (эффективно, надежно)

Есть ли какой-то универсальный способ проверить, что наш софт работает правильно?

* Запустить программу (Запуском можно проверить большинство Функциональных и Нефункциональных требований)
* Посмотреть на код (Это слишком сложно. У нас может быть разное окружение, разные библиотеки, нужно точно знать как работает стандартная библиотека => **Статический анализ это сложно!**)

Поэтому **тестирование** --- это один из методов обеспечения качества ПО, который запускает программу и проверяет, отвечает ли эта программа каким-то требованиям.

Тестирование отвечает на вопрос: 
> Работает ли ПО неправильно?

Потому что гарантировать, что-то другое мы не можем ~~Кроме формальной верификации, но это уже другая история~~

Фундоментальная проблема тестирования:

**Невозможно гарантировать, что для данного софта, не найдется ситуации, что что-то будет работать не так как нужно**

У тестирования есть два старших брата:
* Верификация – «мы сделали это правильно»
* Валидация – «мы сделали то, что надо»

В силу того, что тестирование ограничено каким-то набором запусков, то мы никогда не можем гарантировать, что приложение не упадёт и прочее.

Тестированием нужно заниматься как можно раньше, так как цена ошибки с каждой стадией проекта становится всё дороже (выпустив релиз с багом придётся его фиксить так, чтобы ничего не развалилось у конечных пользователей при обновлении)

# 2. Модель программной ошибки. Модель тестирования ПО и место тестирования в процессе разработки ПО.
Тестирование с точки зрения дилетанта:

> Запустили приложение и проверили результаты выполнения на предмет наличия в них ошибок

## Модель программной ошибки

1. **Ошибка(Error)** –-- ошибка в самой программе, внесенная на этапе разработки (что-то
написано в исходном коде так, что может привести к тому, что программа будет вести себя не так, как нужно)

1. **Сбой(Fault)** –-- некорректное состояние программы из-за ошибки (задедлочилась программа, что-то неправильно посчиталось)

1. **Неудача(Failure)** –-- наблюдаемое **снаружи** некорректное поведение программы (упала, зависла)

**Важная мысль тестирования:** большая часть того, чем занимается тестирование, это попытка сделать так, чтобы максимальное количество ошибок, разбросанные по программе, были залевелаплены аж до видимой снаружи неудачи.

## Модель тестирования ПО

```
Программная обеспечение
        |
       <?> — Результаты тестирования
        |
Эталонная модель
```

**Эталонная модель** может быть представлена множеством различных способов:
* Набор тестовых примеров
* Корректные результаты работы программы
* Формальная техническая спецификация
* Другая реализация

Почему тест может не пройти из-за:
* Проблема в ПО
* Проблема в тестовом окружении (Другие компоненты от которых зависит тестируемый компонент)
* Проблема в программно-аппаратная платформа 
* Проблема в Эталонной модели
* Проблема в оракуле

## Проблемы тестирования

1. Проблема тестовых входных данных
1. Проблема наблюдаемости (Не всегда можно просто изменяя входные данные добраться до *Неудачи*)
1. Проблема останова (Когда заканчивать тестирование)
1. Проблема тестового оракула

## Тестирование в процессе разработки ПО

### Модели разработки ПО

В большинстве подходов к разработке тестирование занимает большую чать работы 

1. Водопадная модель
    
    Тестирование выполняется над всей программой сразу, поэтому это немного упрощает задачу

    **Плюсы** 
    * В момент тестирования у нас есть всё, то есть вся программа уже реализована
    * Имеется хорошая эталонная модель (Так как есть хорошая документация и тех задание)

    **Минусы**    
    * Стоимость поиска и исправления ошибок очень высока
    
1. Инкрементальная модель

    Разработка проходит в несколько итераций

    **Плюсы**
    * Имеется не плохая эталонная модель
    
    **Минусы**
    * Стоимость поиска и исправления ошибок достаточно высока

1. Agile-подходы

    Все этапы разработки неразрывно связаны друг с другом

    **Плюсы**
    * Стоимость поискаи и исправления ошибок низкая

    **Минусы**
    * Эталонная модель есть не всегда (почти всегда нужны заглушки, так как нет еще какого-то модуля)
    * Если в процессе тестирования, что-то построено не совсем правильно, то это может достаточно сильно повлиять на то, что дальше всё может немного заработать неправильно
        * Тесты вообще не запускаются или работают не правильно
        * Ошибка в эталонной модели или при запуске тестов и мы думаем, что все плохо.

# 3. Проблема тестовых входных данных

[В пдф кобыжева стр. 5](./Расписанные_билеты_Тестирование_ПО.pdf#page=5)

# 4. Проблема неявных входных данных

[В пдф кобыжева стр. 7](./Расписанные_билеты_Тестирование_ПО.pdf#page=5)

# 5. Разработка через тестирование

[В пдф кобыжева стр. 8](./Расписанные_билеты_Тестирование_ПО.pdf#page=8)

Самый большой минус:

* При внесении изменений в интерфейсы компонентов системы необходимо изменить все тесты. Это может быть очеь дорого

* Невозможность тестирования сложного взаимодействия нескольких компонентов

# 6. Интеграционное тестирование

Интеграционное тестирование --- тестирует два или более модулей вместе

## Проблема большого взрыва

Когда-нибудь мы захотим заменить заглушку на реализацию, и в больших системах реализация может отличаться поведением от заглушки(и чаще всего так и будет). 

И после замены проблема может проявляться не напрямую, а **распространяться каскадно**. Такую ошибку **тяжело локализовать**, а **стоимость исправления** может быть большой, так как замена может происходить, когда уже написан ряд компонентов с упором на заглушку. 

Из-за замены большого числа заглушек на реализацию возникает **Проблема большого взрыва**

## Как бороться

* Протестировать заглушку относительно реализации
* Заглушку пишет разработчик, который реализовывал функциональность
* *Ускорить процесс замены заглушек на реализацию*

Замена заглушек на реализацию инкрементально --- **Инкрементальное интеграционное тестирование**

## Нисходящее интеграционное тестироване

* Тестирование начинается с верхних уровней системы (ядро системы, основные модули)
* Отсутствующие на данный момент модули заменяются “заглушками”
* По мере реализации новых модулей они подключаются к системе вместо “заглушек”

**Плюсы**
1. Возможность ранней проверки корректности ядра системы
1. Модули могут добавляться по одному, независимо друг от друга
1. Не требуется разработка множества драйверов (заглушка специального типа, которая находится сверху и умеет что-то делать с модулями, которые находятся ниже драйвера)
1. Можно разрабатывать систему как в глубину, так и в ширину

**Минусы**
1. Поздняя проверка перефирии (высокоуровнего поведения --- не ядра системы)
1. Требуется разрботка "заглушек"
1. **Крайне сложно корректно сформулировать требования ко входам/выходам частичной системы** 

    ```
            1
            /\
           2  3
          /
         4 
    ```
    Чтобы понять что должно быть на выходе у 1 если у нас есть 4,2,3 может быть не тривиально из спецификации

## Восходящее интеграционное тестирование

Тестирование начинается с нижних уровней (не ядра), так как там всегда есть хорошая спецификация, что должно быть на входе и на выходе (решаем проблему 3. из Нисходящего интеграционного тестирования) 

Отсутствующие на данный момент модули заменяются драйверами (Особого вида заглушка, которая умеет взаимодействовать или имитировать взаимодействие с ядром системы)

**Плюсы**
1. Возможность ранней проверки корректности низкоуровневого поведения (не ядра)
1. Не требует написания заглушек, но требуется писать драйвера
1. Просто определить требования ко входам/выходам (3. проблема нисходящего интеграционного тестироване)

**Минусы**
1. Отложенная проверка высокоуровневого поведения (ядра)
1. Требуется разработка драйверов
1. При замене драйвера на модуль высокого уровня может произойти “мини-Большой Взрыв”

**На практике используется комбинация нисходящего и восходящего интеграционного тестирования**

# 7. Проблема наблюдаемости. Ассерты.

## Проблема наблюдаемости

На практике тяжело изменяя входные данные превратить *сбой* с *неудачу*.

Поэтому нужно использовать второй способ управления выполнением кода --- **изменение исходного кода**

## Ассерты (Assert)

Assertion:
* Формула в логике первого порядка (более сложные логики на ЯП не пишутся)
* Проверяется на истинность во время выполнения программы.

Assertions позволяют проверить корректность внутреннего состояния:
* Внутреннее состояние обычно должно быть недоступно снаружи (из-за инкапсуляции)
* При изменении состояния хочется проверить, что оно остается корректным

Неудача происходит ближе к причине ее возникновения:
* Чем больше задержка перед обнаружением неудачи, тем сложнее найти ее исходную причину, Assertions позволяют найти неудачу практически в любой точке программы

Явное документирование пред- и постусловий:
* Позволяет проверить, что состояние программы до или после ф-ции находится в корректном состоянии

## Проблемы Assertions

1. Ошибки в ассертах. 
    * Могут изменять внутреннее состояние, тогда при их включении или отключении программа будет вести себя по-разному.
    * Просто неправильное условие (будем лишний раз падать)
1. Влияние на производительность
1. Эффект "вышибалы"
    * Сработавший ассерт превращает ошибку сразу в неудачу. И пока мы не поправим этот баг, продолжать тестирование нельзя, даже если это что-то незначительное
1. Сложность проверки определенных условий
    * Некоторые условия сложно проверить в ассерте

